# lab2

## 使用方法

在`lab2`目录下执行
```shell
$ make
$ ./bwsh
```
即可运行。

之后可以
```shell
$ make clean
```
以清除被存放在`\obj`目录下项目生成的`.obj`文件。

## 特性
- 有较强的健壮性，输入时不必刻意控制管道和重定向符等左右的空格，以及加入了报错处理。
- 有命令行提示符。
- 支持`tab`补全，以及上下查看历史命令。
- 支持管道，修改环境变量，文件重定向。
- 支持管道最前端的文件输入重定向和管道最后端的文件输出重定向(e.g."$ wc < temp.l | wc | wc > a.txt")。
- 支持文件重定向组合。
- 支持以`;`或者`&&`分割的多个命令执行。
- 支持任务后台运行（但是暂时未实现类似`bash`的任务挂到后台时的`stdout`输出）。

## 设计思路

本次实验实现一个 shell 程序。

为了保证健壮性，在听取了刘紫檀同学的建议，并在其帮助下（实名感谢刘紫檀同学指导），选择使用`Lex + Yacc`来处理用户的命令行输入。

`shell.l`文件定义了词法规范，处理用户可能输入的空格，`tab`等字符，并且返回识别到的字符，以及词。

`shell.y`文件定义了语法规范，用来分析构建命令行的语句。根据`lex`返回的词，来分析输入属于哪一种语法结构。分析过程中将必要的参数填入`simplecommand`结构体中（如命令总数，是否有文件重定向，命令参数等），方便`main`函数进行操作。

`main`函数调用`yyparse()`进行语法分析之后返回得到分析后的命令以及参数。`main`函数内再根据命令个数等执行管道，文件重定向等操作。

## 一些函数调用

### 关于`exit()`和`_exit()`

> `exit()`与`_exit()`的基本区别在于前一个调用实施与调用库里用户状态结构 (user-mode constructs)有关的清除工作(clean-up)，而且调用用户自定义的清除程序 (译者注：自定义清除程序由atexit函数定义，可定义多次，并以倒序执行)，相对应，后一个函数只为进程实施内核清除工作。 

> 在由`fork()`创建的子进程分支里，正常情况下使用`exit()`是不正确的，这是因为使用它会导致标准输入输出(译者注：stdio: Standard Input Output)的缓冲区被 清空两次，而且临时文件被出乎意料的删除(译者注：临时文件由tmpfile数创建 在系统临时目录下，文件名由系统随机生成)。在C++程序中情况会更糟，因为静 态目标(static objects)的析构函数(destructors)可以被错误地执行。(还有一些特殊情 况，比如守护程序，它们的*父进程*需要调用`_exit()`而不是子近程；适用于绝 大多数情况的基本规则是，`exit()`在每一次进入‘main’函数后只调用一次)。

### 关于 background 的操作

调用`waitpid(pid, NULL, WNOHANG)`不阻塞父进程，直接返回。

关于 background 的后续实现，个人觉得可以维护一个关于后台任务的链表，每个链表项包含任务的`pid`、序号以及任务完成情况等等。接收到后台任务时，插入链表，打印终端提示符之前检查是否有后台进程完成，如果有则对链表进行维护（删除等）操作。但是现在还没有完成这些任务。

## 一些问题

目前对于管道中的重定向操作还不能实现和`bash`一样的结果。例如

```shell
$ ls |wc < a.txt | ......
```

对于前两个命令，`wc`统计的是`ls`输出和`a.txt`的字符的和，目前`bwsh`只能做到支持管道第一条命令的输入重定向和最后一条命令的重定向，并不能产生`bash`中这样的结果。

由于时间关系，还有一些特性没有实现，例如对于带括号的命令的处理，`<<<`等重定向等等。

## 参考资料

[1. Lex and Yacc](https://www.ibm.com/developerworks/cn/linux/sdk/lex/index.html)

[2. 文件描述符](https://akaedu.github.io/book/ch29s03.html)

[3. 任务调度管理](https://akaedu.github.io/book/ch30s03.html)
